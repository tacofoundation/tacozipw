import{_ as a,c as t,a2 as n,o as s}from"./chunks/framework.CtkhMaM1.js";const u=JSON.parse('{"title":"Tacozip","description":"","frontmatter":{},"headers":[],"relativePath":"en/python/overview.md","filePath":"en/python/overview.md"}'),i={name:"en/python/overview.md"};function r(o,e,l,d,p,c){return s(),t("div",null,e[0]||(e[0]=[n(`<h1 id="tacozip" tabindex="-1">Tacozip <a class="header-anchor" href="#tacozip" aria-label="Permalink to &quot;Tacozip&quot;">​</a></h1><h2 id="purpose-and-scope" tabindex="-1">Purpose and scope <a class="header-anchor" href="#purpose-and-scope" aria-label="Permalink to &quot;Purpose and scope&quot;">​</a></h2><p>Tacozip is a specialized ZIP archive library optimized for fast metadata access in cloud storage scenarios. It creates standard ZIP archives with a custom TACO Header at byte 0, enabling metadata retrieval via a single 165-byte read operation instead of scanning the entire Central Directory.</p><p><strong>Key innovation</strong>: Traditional ZIP readers must seek to the archive end to read the Central Directory before accessing metadata. Tacozip eliminates this bottleneck by embedding metadata at the file start, enabling efficient HTTP range requests like <code>Range: bytes=0-164</code>.</p><p>This document covers architecture fundamentals and component relationships. For implementation details, see:</p><ul><li><strong>TACO header format</strong> - Header structure and serialization</li><li><strong>C library reference</strong> - Native API documentation</li><li><strong>Python client</strong> - Python bindings and usage</li><li><strong>Getting started</strong> - Installation and examples</li></ul><h2 id="what-is-tacozip" tabindex="-1">What is <code>tacozip</code>? <a class="header-anchor" href="#what-is-tacozip" aria-label="Permalink to &quot;What is \`tacozip\`?&quot;">​</a></h2><p>Tacozip addresses the performance penalty of Central Directory scanning in large ZIP archives accessed over HTTP or cloud storage. The library embeds a TACO Header containing up to 7 metadata entries (offset/length pairs) at the archive start, enabling single-request metadata retrieval.</p><h3 id="core-specifications" tabindex="-1">Core specifications <a class="header-anchor" href="#core-specifications" aria-label="Permalink to &quot;Core specifications&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Feature</th><th>Value</th><th>Rationale</th></tr></thead><tbody><tr><td><strong>Compression</strong></td><td>STORE only (method 0)</td><td>Predictable offsets for range requests</td></tr><tr><td><strong>Header size</strong></td><td>165 bytes fixed</td><td>Minimal overhead, single-read access</td></tr><tr><td><strong>Metadata capacity</strong></td><td>7 entries maximum</td><td>Balances flexibility with size constraints</td></tr><tr><td><strong>Archive limit</strong></td><td>4GB (no ZIP64)</td><td>Simplified implementation, common case optimization</td></tr><tr><td><strong>ZIP backend</strong></td><td>libzip 1.11.4</td><td>Production-proven ZIP operations</td></tr><tr><td><strong>CRC32</strong></td><td>zlib 1.3.1</td><td>Fast integrity verification</td></tr></tbody></table><p><strong>Design constraints</strong>:</p><ul><li>Read-optimized: Prioritizes fast metadata access over write performance</li><li>Cloud-native: HTTP range request compatible by design</li><li>Standard-compliant: Regular ZIP format, readable by all ZIP tools</li></ul><h2 id="taco-header" tabindex="-1">TACO header <a class="header-anchor" href="#taco-header" aria-label="Permalink to &quot;TACO header&quot;">​</a></h2><p>The TACO Header is a 165-byte structure at offset 0 containing up to 7 metadata entries (offset/length pairs). It appears as a regular ZIP entry to maintain compatibility with standard tools.</p><p><strong>Key benefits:</strong></p><ul><li><strong>Single-read access</strong>: One 165-byte read retrieves all metadata</li><li><strong>Efficient updates</strong>: Only ~200 bytes written, regardless of archive size</li><li><strong>HTTP friendly</strong>: <code>Range: bytes=0-164</code> retrieves complete metadata in one request</li></ul><p>For complete header specification, see <a href="./header.html">TACO Header Format</a>.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h2><p>Tacozip uses a layered architecture separating low-level ZIP manipulation from high-level bindings.</p><h3 id="component-stack" tabindex="-1">Component stack <a class="header-anchor" href="#component-stack" aria-label="Permalink to &quot;Component stack&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>┌───────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│ Application Layer                                 │</span></span>
<span class="line"><span>│ (User Code)                                       │</span></span>
<span class="line"><span>└───────────────────────────────────────────────────┘</span></span>
<span class="line"><span>                    │</span></span>
<span class="line"><span>┌───────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│ Python API Layer                                  │</span></span>
<span class="line"><span>│ - Public functions (create, read_header, etc.)    │</span></span>
<span class="line"><span>│ - Parameter validation                            │</span></span>
<span class="line"><span>│ - Error handling                                  │</span></span>
<span class="line"><span>└───────────────────────────────────────────────────┘</span></span>
<span class="line"><span>                    │</span></span>
<span class="line"><span>┌───────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│ FFI Layer (ctypes bindings)                       │</span></span>
<span class="line"><span>│ - C structure definitions                         │</span></span>
<span class="line"><span>│ - Function signatures                             │</span></span>
<span class="line"><span>│ - Data marshaling                                 │</span></span>
<span class="line"><span>└───────────────────────────────────────────────────┘</span></span>
<span class="line"><span>                    │</span></span>
<span class="line"><span>┌───────────────────────────────────────────────────┐</span></span>
<span class="line"><span>│ Native Library (C + libzip)                       │</span></span>
<span class="line"><span>│ - ZIP manipulation logic                          │</span></span>
<span class="line"><span>│ - Header serialization                            │</span></span>
<span class="line"><span>│ - File I/O operations                             │</span></span>
<span class="line"><span>└───────────────────────────────────────────────────┘</span></span></code></pre></div><h3 id="dual-api-strategy" tabindex="-1">Dual API strategy <a class="header-anchor" href="#dual-api-strategy" aria-label="Permalink to &quot;Dual API strategy&quot;">​</a></h3><p>Tacozip provides two API levels for different use cases:</p><p><strong>High-Level API</strong> (Convenience):</p><ul><li><code>tacozip_create()</code> - Create archive from files</li><li><code>tacozip_read_header()</code> - Read header from file</li><li><code>tacozip_update_header()</code> - Update header in file</li></ul><p><strong>Low-Level API</strong> (Zero-Copy):</p><ul><li><code>tacozip_parse_header()</code> - Parse header from buffer</li><li><code>tacozip_serialize_header()</code> - Serialize header to buffer</li></ul><p>The low-level API operates on memory buffers without I/O, enabling custom storage backends (S3, Azure Blob, etc.) and zero-copy optimizations.</p><h2 id="core-components" tabindex="-1">Core components <a class="header-anchor" href="#core-components" aria-label="Permalink to &quot;Core components&quot;">​</a></h2><h3 id="native-c-library" tabindex="-1">Native C library <a class="header-anchor" href="#native-c-library" aria-label="Permalink to &quot;Native C library&quot;">​</a></h3><p>The C library (<code>src/tacozip.c</code>) implements all ZIP operations:</p><table tabindex="0"><thead><tr><th>Function</th><th>Purpose</th><th>Key Operations</th></tr></thead><tbody><tr><td><code>tacozip_create</code></td><td>Create archive</td><td>libzip integration, STORE compression enforcement</td></tr><tr><td><code>tacozip_read_header</code></td><td>Read from file</td><td>165-byte read, delegates to parse function</td></tr><tr><td><code>tacozip_parse_header</code></td><td>Parse from buffer</td><td>LFH validation, metadata extraction</td></tr><tr><td><code>tacozip_serialize_header</code></td><td>Serialize to buffer</td><td>CRC32 computation, LFH construction</td></tr><tr><td><code>tacozip_update_header</code></td><td>Update in file</td><td>Atomic 3-location write</td></tr><tr><td><code>tacozip_detect_format</code></td><td>Detect ZIP32/ZIP64</td><td>Format identification for validation</td></tr><tr><td><code>tacozip_validate</code></td><td>Integrity check</td><td>3-level validation (quick/normal/deep)</td></tr></tbody></table><p><strong>Performance optimizations</strong>:</p><ul><li>Direct file manipulation bypasses libzip for updates</li><li>Minimal writes (only changed bytes, not full structures)</li><li>1MB copy buffers for efficient file operations</li><li>Adaptive Central Directory search based on file size</li></ul><h3 id="python-client" tabindex="-1">Python client <a class="header-anchor" href="#python-client" aria-label="Permalink to &quot;Python client&quot;">​</a></h3><p>The Python package (<code>clients/python/tacozip/</code>) provides high-level bindings:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tacozip/</span></span>
<span class="line"><span>├── __init__.py       # Public API exports</span></span>
<span class="line"><span>├── bindings.py       # ctypes FFI layer</span></span>
<span class="line"><span>├── loader.py         # Library loading and discovery</span></span>
<span class="line"><span>├── config.py         # Constants and error codes</span></span>
<span class="line"><span>├── exceptions.py     # Error handling</span></span>
<span class="line"><span>└── version.py        # Version detection</span></span></code></pre></div><p><strong>Layer responsibilities</strong>:</p><ol><li><strong>Public API</strong> (<code>__init__.py</code>): User-facing functions, parameter validation</li><li><strong>FFI layer</strong> (<code>bindings.py</code>): ctypes structures, function signatures, marshaling</li><li><strong>Loader</strong> (<code>loader.py</code>): Cross-platform library loading</li><li><strong>Config</strong> (<code>config.py</code>): Constants shared with C layer</li></ol><h3 id="data-flow-create-operation" tabindex="-1">Data flow: create operation <a class="header-anchor" href="#data-flow-create-operation" aria-label="Permalink to &quot;Data flow: create operation&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>User Code</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>    ├─&gt; create(zip_path, files, entries)</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>Python API Layer</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>    ├─&gt; Validate inputs</span></span>
<span class="line"><span>    ├─&gt; Prepare ctypes arrays</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>FFI Layer</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>    ├─&gt; Marshal to C types</span></span>
<span class="line"><span>    ├─&gt; Call tacozip_create()</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>C Library</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>    ├─&gt; zip_open() [libzip]</span></span>
<span class="line"><span>    ├─&gt; Add TACO_HEADER entry</span></span>
<span class="line"><span>    ├─&gt; Add user files (STORE only)</span></span>
<span class="line"><span>    ├─&gt; zip_close() [libzip]</span></span>
<span class="line"><span>    │</span></span>
<span class="line"><span>    └─&gt; Return status code</span></span></code></pre></div><h2 id="key-design-decisions" tabindex="-1">Key design decisions <a class="header-anchor" href="#key-design-decisions" aria-label="Permalink to &quot;Key design decisions&quot;">​</a></h2><h3 id="_1-store-only-compression" tabindex="-1">1. STORE-only compression <a class="header-anchor" href="#_1-store-only-compression" aria-label="Permalink to &quot;1. STORE-only compression&quot;">​</a></h3><p><strong>Decision</strong>: Enforce <code>ZIP_CM_STORE</code> (compression method 0) for all entries.</p><p><strong>Rationale</strong>:</p><ul><li>Predictable file offsets enable efficient HTTP range requests</li><li>Zero decompression overhead for cloud workloads</li><li>Simplified implementation without compression algorithm management</li></ul><p><strong>Trade-off</strong>: Larger archive sizes vs. faster access and simpler code</p><h3 id="_2-fixed-165-byte-header" tabindex="-1">2. Fixed 165-byte header <a class="header-anchor" href="#_2-fixed-165-byte-header" aria-label="Permalink to &quot;2. Fixed 165-byte header&quot;">​</a></h3><p><strong>Decision</strong>: TACO Header is exactly 165 bytes (30 LFH + 19 filename + 116 payload).</p><p><strong>Rationale</strong>:</p><ul><li>Single read operation retrieves complete metadata</li><li>Updates don&#39;t require rewriting surrounding structures</li><li>Compatible with standard ZIP readers (appears as regular entry)</li></ul><p><strong>Trade-off</strong>: Fixed size limits metadata capacity vs. update efficiency</p><h3 id="_3-no-zip64-support" tabindex="-1">3. No ZIP64 support <a class="header-anchor" href="#_3-no-zip64-support" aria-label="Permalink to &quot;3. No ZIP64 support&quot;">​</a></h3><p><strong>Decision</strong>: Limit archives to 4GB, no ZIP64 format support.</p><p><strong>Rationale</strong>:</p><ul><li>Simplified implementation (ZIP64 adds significant complexity)</li><li>4GB covers vast majority of use cases</li><li>Reduced code size and maintenance burden</li></ul><p><strong>Trade-off</strong>: Cannot create &gt;4GB archives vs. simpler codebase</p><h3 id="_4-maximum-7-metadata-entries" tabindex="-1">4. Maximum 7 metadata entries <a class="header-anchor" href="#_4-maximum-7-metadata-entries" aria-label="Permalink to &quot;4. Maximum 7 metadata entries&quot;">​</a></h3><p><strong>Decision</strong>: Support up to 7 offset/length pairs in header.</p><p><strong>Rationale</strong>:</p><ul><li>Keeps payload at 116 bytes (fits with 165-byte total)</li><li>Sufficient for common scenarios (multiple Parquet files, etc.)</li><li>Enables efficient in-place updates</li></ul><p><strong>Trade-off</strong>: Limited metadata capacity vs. compact header size</p><h3 id="_5-direct-file-manipulation" tabindex="-1">5. Direct file manipulation <a class="header-anchor" href="#_5-direct-file-manipulation" aria-label="Permalink to &quot;5. Direct file manipulation&quot;">​</a></h3><p><strong>Decision</strong>: Bypass libzip for <code>update_header</code> and <code>validate</code> operations.</p><p><strong>Rationale</strong>:</p><ul><li>Atomic updates with rollback capability</li><li>Minimal rewrites (only changed bytes)</li><li>Fine-grained control over ZIP structures</li></ul><p><strong>Trade-off</strong>: More complex C code vs. better performance</p><h3 id="_6-build-from-source-strategy" tabindex="-1">6. Build from source strategy <a class="header-anchor" href="#_6-build-from-source-strategy" aria-label="Permalink to &quot;6. Build from source strategy&quot;">​</a></h3><p><strong>Decision</strong>: Build libzip from source in CI/CD instead of using system libraries.</p><p><strong>Rationale</strong>:</p><ul><li>Version consistency across platforms</li><li>Controlled dependency management</li><li>Reproducible builds</li></ul><p><strong>Trade-off</strong>: Longer build times vs. consistent behavior</p><h2 id="implementation-highlights" tabindex="-1">Implementation highlights <a class="header-anchor" href="#implementation-highlights" aria-label="Permalink to &quot;Implementation highlights&quot;">​</a></h2><h3 id="memory-management" tabindex="-1">Memory management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory management&quot;">​</a></h3><p><strong>Stack allocation</strong> for fixed-size structures:</p><ul><li>TACO Header uses 165-byte stack buffer</li><li>Predictable memory footprint</li></ul><p><strong>Heap allocation</strong> with explicit cleanup:</p><ul><li>Central Directory buffer allocated dynamically</li><li>Cleanup via <code>goto fail</code> pattern for error paths</li></ul><p><strong>Python GC safety</strong>:</p><ul><li>ctypes structures maintain references during calls</li><li>Prevents premature garbage collection of buffers</li></ul><h3 id="error-handling" tabindex="-1">Error handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error handling&quot;">​</a></h3><p>Consistent patterns across layers:</p><table tabindex="0"><thead><tr><th>Layer</th><th>Mechanism</th><th>Example</th></tr></thead><tbody><tr><td><strong>C library</strong></td><td>Integer return codes</td><td><code>TACOZ_OK (0)</code>, <code>TACOZ_ERR_IO (-1)</code></td></tr><tr><td><strong>Python bindings</strong></td><td>Exceptions</td><td><code>TacozipError</code>, <code>TacozipIOError</code></td></tr><tr><td><strong>CI/CD</strong></td><td>Exit codes</td><td>Non-zero exit on failures</td></tr></tbody></table><p><strong>Error propagation</strong>: C errors → Python exceptions → User code</p><h3 id="platform-compatibility" tabindex="-1">Platform compatibility <a class="header-anchor" href="#platform-compatibility" aria-label="Permalink to &quot;Platform compatibility&quot;">​</a></h3><p><strong>Cross-platform support</strong>:</p><ul><li>Preprocessor directives for platform-specific code</li><li>CMake feature detection (<code>posix_fallocate</code>, etc.)</li><li>Dynamic library naming (<code>.so</code>, <code>.dylib</code>, <code>.dll</code>)</li></ul><p><strong>Tested platforms</strong>:</p><ul><li>Linux (x86_64, ARM64)</li><li>macOS (Intel, Apple Silicon)</li><li>Windows (x64)</li></ul><h2 id="performance-characteristics" tabindex="-1">Performance characteristics <a class="header-anchor" href="#performance-characteristics" aria-label="Permalink to &quot;Performance characteristics&quot;">​</a></h2><h3 id="read-operations" tabindex="-1">Read operations <a class="header-anchor" href="#read-operations" aria-label="Permalink to &quot;Read operations&quot;">​</a></h3><ul><li><strong>Header read</strong>: O(1) - Single 165-byte read at offset 0</li><li><strong>File access</strong>: O(1) - Direct seek using metadata offsets</li><li><strong>Full scan</strong>: Not required - Metadata available immediately</li></ul><h3 id="write-operations" tabindex="-1">Write operations <a class="header-anchor" href="#write-operations" aria-label="Permalink to &quot;Write operations&quot;">​</a></h3><ul><li><strong>Archive creation</strong>: O(n) in number of files</li><li><strong>Header update</strong>: O(1) - Writes 3 locations regardless of archive size</li><li><strong>Validation</strong>: O(n) in validation level (quick/normal/deep)</li></ul><h3 id="comparison-with-standard-zip" tabindex="-1">Comparison with standard ZIP <a class="header-anchor" href="#comparison-with-standard-zip" aria-label="Permalink to &quot;Comparison with standard ZIP&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operation</th><th>Standard ZIP</th><th>Tacozip</th></tr></thead><tbody><tr><td>Metadata access</td><td>Seek to end, scan CD</td><td>Read 165 bytes at offset 0</td></tr><tr><td>HTTP requests for metadata</td><td>2+ (end, then CD)</td><td>1 (range request)</td></tr><tr><td>Compression overhead</td><td>Variable</td><td>Zero (STORE only)</td></tr><tr><td>Archive size limit</td><td>4GB / 16EB (ZIP64)</td><td>4GB</td></tr></tbody></table><h2 id="next-steps" tabindex="-1">Next steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next steps&quot;">​</a></h2><p><strong>For Python users:</strong></p><ul><li>Start with <a href="./getting-started.html">Getting Started</a> for installation and basic usage</li><li>Review <a href="./client.html">Python Client</a> for Python-specific features</li><li>See <a href="./use-cases.html">Use Cases</a> for real-world examples</li></ul><p><strong>For C developers:</strong></p><ul><li>Read <a href="#">C API Reference</a> for native library details</li><li>Study <a href="./header.html">TACO Header Format</a> for specification details</li></ul><p><strong>For contributors:</strong></p><ul><li>Review <a href="./CONTRIBUTING.html">Contributing Guidelines</a> for code standards</li></ul>`,103)]))}const g=a(i,[["render",r]]);export{u as __pageData,g as default};
