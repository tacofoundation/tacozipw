import{_ as s,c as i,a2 as a,o as t}from"./chunks/framework.CtkhMaM1.js";const n="/tacozip/assets/content-gdal-cog.DGr9XP5p.svg",r="/tacozip/assets/tiled.CIugydVl.gif",l="/tacozip/assets/geotiff_vs_cog.DhjCvvYD.svg",E=JSON.parse('{"title":"The Cloud Optimized GeoTIFF format","description":"","frontmatter":{},"headers":[],"relativePath":"en/specification/cog.md","filePath":"en/specification/cog.md"}'),o={name:"en/specification/cog.md"};function h(d,e,p,c,k,g){return t(),i("div",null,e[0]||(e[0]=[a('<h1 id="the-cloud-optimized-geotiff-format" tabindex="-1">The Cloud Optimized GeoTIFF format <a class="header-anchor" href="#the-cloud-optimized-geotiff-format" aria-label="Permalink to &quot;The Cloud Optimized GeoTIFF format&quot;">â€‹</a></h1><p><em>Written by Cesar Aybar and Julio Contreras.</em></p><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">â€‹</a></h2><p>We are old enough to remember that analyzing a tiny 1 MB region required downloading entire satellite images (&gt;1 GB each) to our local machines. But around in 2016, the Cloud Optimized GeoTIFF (COG) format changed everything. Suddenly, with one/few lines of code, we could download precisely the region we needed, nothing more. What makes COG so special? The magic lies in two key innovations: <strong>server-side optimization</strong> and the <strong>file byte order</strong>. In this article, we will explore the technical foundations of COG, and why it has become the gold standard for efficient remote sensing data access in the cloud era.</p><figure style="display:flex;flex-direction:column;align-items:center;"><img src="'+n+`" alt="Band GIF" style="width:60%;"></figure><h2 id="requirements-to-become-a-cog" tabindex="-1">Requirements to become a COG <a class="header-anchor" href="#requirements-to-become-a-cog" aria-label="Permalink to &quot;Requirements to become a COG&quot;">â€‹</a></h2><p>To enable partial reads in a COG, the following requirements must be satisfied:</p><p><strong>Server-Side Requirements:</strong></p><ul><li><code>HTTP/1.1+ Range Request Support</code>: The hosting server must accept Range headers (we will see what this means later).</li></ul><p><strong>File Requirements:</strong></p><ul><li><p>Valid GeoTIFF structure.</p></li><li><p>Can be compressed or uncompressed.</p></li><li><p>Tiled Data Organization: <code>TILE=YES</code> and <code>BLOCKXSIZE</code>/<code>BLOCKYSIZE</code> tags set in the GeoTIFF file. Pixel data is divided into square tiles (e.g., 256x256 or 512x512) rather than stripped layouts.</p></li><li><p>Interleave chunk organization: From GDAL 3.11 onwards, the <code>INTERLEAVE</code> tag can be set as <code>PIXEL</code>, <code>BAND</code>, or <code>TILE</code>. Before GDAL 3.11, the default and only option was <code>PIXEL</code>.</p></li><li><p>Internal Overviews: Pyramid-style reduced-resolution versions (overviews) embedded within the file for rapid zoom-level rendering.</p></li><li><p>Optimized Byte Layout: Critical metadata structures, i.e. the Image File Directory (IFD), are positioned at the beginning of the file. This &quot;header-first&quot; design allows clients to parse essential metadata without downloading the entire file.</p></li></ul><h2 id="server-side-requirements-http-range-requests" tabindex="-1">Server-Side Requirements: HTTP Range Requests <a class="header-anchor" href="#server-side-requirements-http-range-requests" aria-label="Permalink to &quot;Server-Side Requirements: HTTP Range Requests&quot;">â€‹</a></h2><p>To enable efficient access to Cloud-Optimized GeoTIFFs (COGs), servers must support <strong>HTTP Range Requests</strong>. This feature, introduced in HTTP/1.1 (1997), allows clients to request specific byte ranges of a resource instead of downloading the entire file, significantly improving performance and reducing bandwidth usage.</p><h3 id="how-range-requests-work" tabindex="-1">How Range Requests Work <a class="header-anchor" href="#how-range-requests-work" aria-label="Permalink to &quot;How Range Requests Work&quot;">â€‹</a></h3><p>A client requests partial content by specifying a byte range in the <code>Range</code> header. For example, if a geospatial analyst needs only bytes 5000â€“6000 of a 1 GB GeoTIFF, perhaps to analyze a specific city or a village, the client sends an HTTP request with the header:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Range: bytes=5000-6000&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://example.com/image.tif</span></span></code></pre></div><p>If the server supports partial content it responds with:</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 206</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Partial Content</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Accept-Ranges</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bytes</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Range</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bytes 5000-6000/1000000000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1001</span></span></code></pre></div><p>The <code>Content-Range</code> header specifies the returned byte range (5000â€“6000) relative to the full file size (1,000,000,000 bytes). By transferring only the required data, bandwidth usage is reduced by 99.9% in this example. While HTTP/1.1 introduced this capability, it has significant limitations for modern workflows. Key issues include:</p><ul><li><a href="https://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noreferrer">head-of-line blocking</a>: A single slow request can delay subsequent ones.</li><li>Lack of true <a href="https://en.wikipedia.org/wiki/Multiplexing" target="_blank" rel="noreferrer">multiplexing</a>: Concurrent range requests require separate TCP connections or suffer from latency when pipelined.</li></ul><p>For example, fetching 3 tiles from a Cloud-Optimized GeoTIFF (COG) might necessitate 3 separate TCP connections under HTTP/1.1, or introduce delays if requests are pipelined. These inefficiencies highlight the need for more advanced protocols like <a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noreferrer">HTTP/2</a>.</p><h3 id="the-http-2-protocol" tabindex="-1">The HTTP/2 protocol <a class="header-anchor" href="#the-http-2-protocol" aria-label="Permalink to &quot;The HTTP/2 protocol&quot;">â€‹</a></h3><p>HTTP/2, released in 2015, transforms how range requests are handled. While the syntax for the <code>Range</code> header remains the same as in HTTP/1.1, the protocol introduces a binary framing layer and multiplexing capabilities.</p><p>For example, consider the scenario of fetching 3 tiles from a Cloud-Optimized GeoTIFF (COG). With HTTP/2, multiple requests can be handled concurrently over a single connection, significantly reducing latency and improving performance. A client can request specific byte ranges, such as 5000â€“6000, 10,000â€“11,000, and 15,000â€“16,000, using a <strong>single HTTP range request!</strong>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -H</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Range: bytes=5000-6000, 10000-11000, 15000-16000&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://example.com/image.tif</span></span></code></pre></div><p>The server responds with a single <code>206 Partial Content</code> payload that includes all three requested ranges, separated by boundaries. Here&#39;s an example response:</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTTP/2 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">206</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Partial Content</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> multipart/byteranges; boundary=EXAMPLE_BOUNDARY</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> [total size]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--EXAMPLE_BOUNDARY</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Range</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bytes 5000-6000/1000000000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...TIFF tile data...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--EXAMPLE_BOUNDARY</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Range</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bytes 10000-11000/1000000000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...TIFF tile data...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--EXAMPLE_BOUNDARY--</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Range</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bytes 15000-16000/1000000000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...TIFF tile data...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--EXAMPLE_BOUNDARY--</span></span></code></pre></div><p>The <code>EXAMPLE_BOUNDARY</code> is a delimiter used in the multipart/byteranges response format to separate the different byte ranges in the payload. It is a unique string defined by the server (in this case, EXAMPLE_BOUNDARY is a placeholder) that ensures the client can correctly parse and distinguish between the multiple parts of the response.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Most cloud object storage services like Amazon S3, Google Cloud Storage, and Azure Blob Storage do not support HTTP/2 yet. So it is important to consider the server-side requirements when working with COGs.</p></div><h2 id="file-requirements" tabindex="-1">File Requirements <a class="header-anchor" href="#file-requirements" aria-label="Permalink to &quot;File Requirements&quot;">â€‹</a></h2><p>Creating a Cloud-Optimized GeoTIFF (COG) with GDAL is a simple process. Key COG features like compression, tiling, internal overviews, and interleaved chunk organization are automatically handled using the command <code>gdal_translate -of COG ...</code>. Starting with GDAL <a href="https://github.com/OSGeo/gdal/pull/11541#event-16013050336" target="_blank" rel="noreferrer">3.11</a>, a new option, <code>INTERLEAVE=TILE</code>, was introduced. This option provides a hybrid approach between <code>PIXEL</code> and <code>BAND</code> interleaved chunk organization (discussed in the previous article in this series).</p><figure style="display:flex;flex-direction:column;align-items:center;"><img src="`+r+`" alt="Tiled GIF" style="width:100%;"><figcaption style="text-align:center;"><b>Figure 1: </b>The \`INTERLEAVE=TILE\` creation option</figcaption></figure><p>The <code>INTERLEAVE=TILE</code> option organizes data into chunks at the band level (<code>1 x H x W</code>), but it orders blocks in a way that is similar to pixel interleaving. This approach allows clients to read multiple bands with a single range request, as the band data bytes are stored contiguously. This feature is particularly useful when working with images that have many bands, such as hyperspectral images.</p><p>For example, consider a hyperspectral image with 200 bands where you need to access the first 10 bands for a specific pixel/region of interest. If the image uses pixel interleaving (<code>C x H x W</code>), a single range request can retrieve all the tile data. However, because the data is compressed, you would need to download all bands, decompress them, extract the desired bands, and discard the rest. Conversely, with band interleaving (<code>1 x H x W</code>), the data for each band is stored separately, requiring 10 separate range requests to access the first 10 bands, as the data is not contiguous. Using <code>INTERLEAVE=TILE</code> (also <code>1 x H x W</code>), the data for these bands <strong>remains contiguous within the chunks</strong>, allowing you to make a single range request to retrieve only the bands you need.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The main drawback of using <code>INTERLEAVE=TILE</code> is that the final file size will be larger compared to using <code>INTERLEAVE=PIXEL</code>. This is because compression is applied at the band level (<code>1 x H x W</code>) rather than the pixel level (<code>C x H x W</code>). The difference in file size depends on the correlation between bands and the compression method used.</p></div><h3 id="optimized-byte-layout" tabindex="-1">Optimized Byte Layout <a class="header-anchor" href="#optimized-byte-layout" aria-label="Permalink to &quot;Optimized Byte Layout&quot;">â€‹</a></h3><p>The Byte Layout is designed to enable efficient access to geospatial data in cloud environments. A key aspect of this layout is the <code>Metadata-First</code> Design, which ensures that metadata is easily accessible by performing a single HTTP range request. This design is crucial for cloud-based workflows, where rapid access to metadata is essential for efficient data processing. Here is how it works:</p><h4 id="ghost-area" tabindex="-1">Ghost Area <a class="header-anchor" href="#ghost-area" aria-label="Permalink to &quot;Ghost Area&quot;">â€‹</a></h4><p>Between the <strong>Image File Header (IFH)</strong> and the first <strong>Image File Directory (IFD)</strong>, there is a region known as the <code>Ghost Area</code> ðŸ‘». This area serves as a critical metadata section that informs GDAL about the structural layout of the file. Letâ€™s take a closer look at the metadata it stores:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GDAL_STRUCTURAL_METADATA_SIZE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">000174</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bytes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LAYOUT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">IFDS_BEFORE_DATA</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BLOCK_ORDER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ROW_MAJOR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BLOCK_LEADER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SIZE_AS_UINT4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BLOCK_TRAILER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">LAST_4_BYTES_REPEATED</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">KNOWN_INCOMPATIBLE_EDITION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">NO</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MASK_INTERLEAVED_WITH_IMAGERY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">YES</span></span></code></pre></div><p>The <code>GDAL_STRUCTURAL_METADATA_SIZE</code> specifies the size of the Ghost Area in bytes. For example, if the <code>MASK_INTERLEAVED_WITH_IMAGERY</code> tag is present, the size is typically 174 bytes; otherwise, it is 140 bytes. The <code>LAYOUT</code> tag indicates the order of the Image File Directories (IFDs), usually set to IFDS_BEFORE_DATA, meaning the IFDs are stored before the actual image data. The <code>BLOCK_ORDER</code> defines the order in which data blocks are stored, only the ROW_MAJOR option is currently supported.</p><p>The <code>BLOCK_LEADER</code> and <code>BLOCK_TRAILER</code> tags are used to verify the integrity of partial downloads. The <code>BLOCK_LEADER</code> specifies the size of each block as a 4-byte unsigned integer (SIZE_AS_UINT4), while the <code>BLOCK_TRAILER</code> ensures the last 4 bytes of each block are repeated for consistency checks.</p><p>The <code>KNOWN_INCOMPATIBLE_EDITION</code> tag is one of the most critical. It indicates whether the COG file is still compliant with the COG specification. For example, if you create a COG file and later append additional overviews (i.e. add new IFDs) using the gdaladdo command, GDAL will automatically set this tag to YES. This signals that the file is no longer a valid COG, and GDAL will issue a warning message.</p><p>Finally, the <code>MASK_INTERLEAVED_WITH_IMAGERY</code> tag indicates whether the COG file contains a band mask with the imagery. For more details on band masks, refer to <a href="https://gdal.org/en/stable/development/rfc/rfc15_nodatabitmask.html" target="_blank" rel="noreferrer">GDAL RFC 15</a>.</p><figure><img src="`+l+`" alt="GeoTIFF file structure" style="width:100%;"><figcaption style="text-align:center;"><b>Figure 2:</b>Differences between a normal GeoTIFF and a COG file structure.</figcaption></figure><h3 id="gdal-tricks-to-read-faster-a-cog-file" tabindex="-1">GDAL tricks to read faster a COG file <a class="header-anchor" href="#gdal-tricks-to-read-faster-a-cog-file" aria-label="Permalink to &quot;GDAL tricks to read faster a COG file&quot;">â€‹</a></h3><p>To optimize GDAL for faster access to Cloud-Optimized GeoTIFFs (COGs), several configuration settings and environment variables can dramatically improve performance. In this last section, we will explore some of these tricks that can help you read COGs more efficiently. For a full list of adjustable parameters, consult the <a href="https://gdal.org/en/stable/user/configoptions.html" target="_blank" rel="noreferrer">GDAL configuration options</a>. Additionally, <a href="https://developmentseed.org/titiler/" target="_blank" rel="noreferrer">TiTiler</a> has a great post about tuning GDAL for COGs that you can find <a href="https://developmentseed.org/titiler/advanced/performance_tuning/" target="_blank" rel="noreferrer">here</a>.</p><h4 id="http-request-optimization" tabindex="-1">HTTP Request Optimization <a class="header-anchor" href="#http-request-optimization" aria-label="Permalink to &quot;HTTP Request Optimization&quot;">â€‹</a></h4><p>Set <code>GDAL_HTTP_MERGE_CONSECUTIVE_RANGES=YES</code> to merge adjacent byte-range requests. For example, instead of requesting bytes 1-5 and 6-10 separately, GDAL will combine them into a single request for bytes 1-10. This reduces the number of round-trip requests. Enable <code>GDAL_HTTP_MULTIPLEX=YES</code> to allow multiplexing multiple range requests over a single HTTP/2 connection (if supported by the server).</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>There is a limit to the number of ranges that can be merged. By default, GDAL will merge up to 2 MB of data. You can adjust this limit by setting the <code>CPL_VSIL_CURL_CHUNK_SIZE</code> environment variable. The maximum value is 10 MB (10485760 bytes). If you increase this value, also consider increasing the <code>CPL_VSIL_CURL_CACHE_SIZE</code> whose default is 16 MB (16384000 bytes). This is quite important because GDAL use a heuristics mechanism to decide when to merge ranges. Consider that larger values will increase RAM consumption.</p></div><h4 id="reduce-filescan" tabindex="-1">Reduce filescan <a class="header-anchor" href="#reduce-filescan" aria-label="Permalink to &quot;Reduce filescan&quot;">â€‹</a></h4><p>Configure <code>GDAL_DISABLE_READDIR_ON_OPEN=EMPTY_DIR</code> to prevent GDAL from scanning the entire directory when opening a file. By default, GDAL lists all files in the directory, which can trigger costly GET/LIST requests. Setting this to EMPTY_DIR skips directory scanning unless external overviews (e.g., .ovr files) are required. If your COGs rely on external overviews, use FALSE instead.</p><h4 id="file-access-restrictions" tabindex="-1">File Access Restrictions <a class="header-anchor" href="#file-access-restrictions" aria-label="Permalink to &quot;File Access Restrictions&quot;">â€‹</a></h4><p>Use <code>CPL_VSIL_CURL_ALLOWED_EXTENSIONS=&quot;.tif,.TIF,.tiff&quot;</code> to restrict GDAL to opening only specified file types. This prevents accidental access to unrelated files.</p><h4 id="header-size-tuning" tabindex="-1">Header Size Tuning <a class="header-anchor" href="#header-size-tuning" aria-label="Permalink to &quot;Header Size Tuning&quot;">â€‹</a></h4><p>Adjust <code>GDAL_INGESTED_BYTES_AT_OPEN</code> to control how many initial bytes GDAL reads to parse metadata. COGs store tile locations in their headers, which can grow large for datasets with many tiles. By default, GDAL reads 16 KB and fetches more if needed.</p><h4 id="caching-strategies" tabindex="-1">Caching Strategies <a class="header-anchor" href="#caching-strategies" aria-label="Permalink to &quot;Caching Strategies&quot;">â€‹</a></h4><ul><li><code>GDAL_CACHEMAX=XXX</code> allocates XXX MB for GDALâ€™s block cache, storing recently accessed tiles in memory.</li><li><code>CPL_VSIL_CURL_CACHE_SIZE=XXX</code> sets a XXX MB global cache for reused network requests.</li><li><code>VSI_CACHE=TRUE</code> enables per-file caching, with <code>VSI_CACHE_SIZE=XXX</code>. This is critical for workflows opening multiple files simultaneously, such as virtual mosaics (VRTs).</li></ul><h4 id="block-cache-type" tabindex="-1">Block Cache Type <a class="header-anchor" href="#block-cache-type" aria-label="Permalink to &quot;Block Cache Type&quot;">â€‹</a></h4><p>GDAL caches chunk tiles (i.e., <code>C x H x W</code> or <code>1 x H x W</code>) to avoid repeated disk/network fetches. However, the default <code>GDAL_BAND_BLOCK_CACHE=ARRAY</code> method pre-allocates memory for every possible block in the dataset. For massive datasets (e.g., high-zoom-level satellite imagery with millions of tiles), this can crash applications due to excessive memory usage. The <code>GDAL_BAND_BLOCK_CACHE=HASHSET</code> method solves this by dynamically allocating memory only for blocks actually accessed, making it far more efficient for large datasets.</p><table tabindex="0"><thead><tr><th>ARRAY</th><th>HASHSET</th></tr></thead><tbody><tr><td>Pre-allocates memory for all blocks.</td><td>Allocates memory only for blocks in use.</td></tr><tr><td>Fast for small datasets (low overhead).</td><td>Better for large datasets (avoids OOM errors).</td></tr><tr><td>Thread-safe without locks (static array).</td><td>Requires mutex locks for thread safety.</td></tr><tr><td>Default for datasets with &lt;1 million blocks.</td><td>Default for datasets with &gt;1 million blocks.</td></tr></tbody></table><p>By default, GDAL uses the <code>AUTO</code> setting, which selects ARRAY for small datasets and HASHSET for large ones. Check the <a href="https://gdal.org/en/stable/development/rfc/rfc26_blockcache.html" target="_blank" rel="noreferrer">GDAL RFC 26</a> for more details.</p><h4 id="proj-network-enhancements" tabindex="-1">Proj Network Enhancements <a class="header-anchor" href="#proj-network-enhancements" aria-label="Permalink to &quot;Proj Network Enhancements&quot;">â€‹</a></h4><p>Enable <code>PROJ_NETWORK=ON</code> to let PROJ fetch high-accuracy transformation grids from the cloud, improving coordinate reprojection for <strong>precision-critical applications</strong>. It is not necessary for UTM grid zones. Check the <a href="https://proj.org/en/stable/community/rfc/rfc-4.html#rfc4" target="_blank" rel="noreferrer">PROJ RFC 4</a> for details.</p><h4 id="final-recommended-configuration" tabindex="-1">Final Recommended Configuration <a class="header-anchor" href="#final-recommended-configuration" aria-label="Permalink to &quot;Final Recommended Configuration&quot;">â€‹</a></h4><p>For most COG workflows, apply these settings:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_HTTP_MERGE_CONSECUTIVE_RANGES</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">YES</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_HTTP_MULTIPLEX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">YES</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_DISABLE_READDIR_ON_OPEN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EMPTY_DIR</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPL_VSIL_CURL_ALLOWED_EXTENSIONS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.tif,.TIF,.tiff&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_INGESTED_BYTES_AT_OPEN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65536</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_CACHEMAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">512</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPL_VSIL_CURL_CACHE_SIZE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">167772160</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPL_VSIL_CURL_CHUNK_SIZE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10485760</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VSI_CACHE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TRUE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VSI_CACHE_SIZE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10485760</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GDAL_BAND_BLOCK_CACHE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HASHSET</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PROJ_NETWORK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ON</span></span></code></pre></div>`,67)]))}const f=s(o,[["render",h]]);export{E as __pageData,f as default};
